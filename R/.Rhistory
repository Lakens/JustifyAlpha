for (i in 1:n){
if(event[i] > 7)
abline(v = i, col = "red", lwd = 2)
}
for (i in 1:n){
if(event[i] < -7)
abline(v = i, col = "purple", lwd = 2)
}
for (t in 2:n) {
#draw a random event from a normal distribution
if (t%%10 == 0)
{
event[t] <- rt(n = 1, df = 2) + emotion[t-1]
}
else{
event[t] <- 0
}
#influence emotion in direction of event
empact <- emotion[t-1] + 0.1* event[t] + rnorm(1, 0, 0.02)
if (empact < 0) {
emotion[t] <- empact + abs(rnorm(1,0, abs(empact/rfact))^4)
}
else {
emotion[t] <- empact - abs(rnorm(1, 0, abs(empact/rfact))^4)
}
#influence cognition in direction of emotion
cogpact <- cognition[t-1] + 0.02* emotion[t] + rnorm(1, 0, 0.02)
if(cogpact < 0) {
cognition[t] <- cogpact + abs(rnorm(1, 0, abs(cogpact/rfact))^4)
} else{
cognition[t] <- cogpact - abs(rnorm(1, 0, abs(cogpact/rfact))^4)
}
#influence wellbeing in direction of cognition
wellpact <- well_being[t-1] + 0.02* cognition[t] + rnorm(1, 0, 0.02)
if(wellpact < 0) {
well_being[t] <- wellpact + abs(rnorm(1, 0, abs(wellpact/rfact))^4)
}else{
well_being[t] <- wellpact - abs(rnorm(1, 0, abs(wellpact/rfact))^4)
}
#chance event mean in direction of emotion --> should be well being in final form
}
#black emotions
plot(emotion, lwd = 3, type = "l", col = "black", axes = F, ylim = c(-3, 3), xlab = "Wellbeing/emotion/cognition", , ylab = "time")
axis(side = 1, lwd = 3)
axis(side = 2, lwd = 3)
#green cognition
lines(cognition, lwd = 3, col = "green")
#blue well_being
lines(well_being, lwd = 3, col = "blue")
##add lines for very good and very bad events
for (i in 1:n){
if(event[i] > 7)
abline(v = i, col = "red", lwd = 2)
}
for (i in 1:n){
if(event[i] < -7)
abline(v = i, col = "purple", lwd = 2)
}
#black emotions
plot(emotion, lwd = 3, type = "l", col = "black", axes = F, ylim = c(-3, 3), ylab = "Wellbeing/emotion/cognition",  xlab = "time")
axis(side = 1, lwd = 3)
axis(side = 2, lwd = 3)
#green cognition
lines(cognition, lwd = 3, col = "green")
#blue well_being
lines(well_being, lwd = 3, col = "blue")
##add lines for very good and very bad events
for (i in 1:n){
if(event[i] > 7)
abline(v = i, col = "red", lwd = 2)
}
for (i in 1:n){
if(event[i] < -7)
abline(v = i, col = "purple", lwd = 2)
}
shiny::runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
library(RoBTT)
library(BayesFactor)
shiny::runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
shiny::runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp('C:/Users/Maximilian Maier/Desktop/PaperWriting/IdealAlpha/JustifieR/inst/shiny-examples/shiny.R')
runApp('C:/Users/Maximilian Maier/Desktop/PaperWriting/IdealAlpha/JustifieR/inst/shiny-examples/shiny.R')
runApp('C:/Users/Maximilian Maier/Desktop/PaperWriting/IdealAlpha/JustifieR/inst/shiny-examples/shiny.R')
runApp('C:/Users/Maximilian Maier/Desktop/PaperWriting/IdealAlpha/JustifieR/inst/shiny-examples/shiny.R')
runApp('C:/Users/Maximilian Maier/Desktop/PaperWriting/IdealAlpha/JustifieR/inst/shiny-examples/shiny.R')
shiny::runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp()
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp()
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp()
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp()
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp()
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp()
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp()
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
IP()
library(rstanarm)
install.packages(rstanarm)
install.packages("rstanarm")
install.packages("rstanarm")
install.packages("rstanarm")
library(rstan)
HEVSD <- "
// Hierarchical Signal Detection Theory
data {
int<lower=1> k;
int<lower=0> h[k];
int<lower=0> f[k];
int<lower=0> s;
int<lower=0> n;
}
parameters {
vector[k] d;
vector[k] c;
real muc;
real mud;
real<lower=0> lambdac;
real<lower=0> lambdad;
}
transformed parameters {
real<lower=0,upper=1> thetah[k];
real<lower=0,upper=1> thetaf[k];
real<lower=0> sigmac;
real<lower=0> sigmad;
sigmac = inv_sqrt(lambdac);
sigmad = inv_sqrt(lambdad);
// Reparameterization Using Equal-Variance Gaussian SDT
for(i in 1:k) {
thetah[i] = Phi(d[i] / 2 - c[i]);
thetaf[i] = Phi(-d[i] / 2 - c[i]);
}
}
model {
// Priors
muc ~ normal(0, inv_sqrt(.001));
mud ~ normal(0, inv_sqrt(.001));
lambdac ~ gamma(.001, .001);
lambdad ~ gamma(.001, .001);
// Discriminability and Bias
c ~ normal(muc, sigmac);
d ~ normal(mud, sigmad);
// Observed counts
h ~ binomial(s, thetah);
f ~ binomial(n, thetaf);
}"
HUSVD <-'
data {
int <lower=1> n;
int <lower=0> HR[n];
int <lower=0> FA[n];
int <lower=0> Si[n];
int <lower=0> No[n];
}
parameters {
vector[n] d;
vector[n] c;
real muc;
real mud;
real<lower=0> lambda;
real<lower=0> sigvar;
}
transformed parameters {
real<lower=0,upper=1> h[n];
real<lower=0,upper=1> f[n];
real<lower=0> sigmas;
real<lower=0> sigmac;
real<lower=0> sigmad;
real sigman;
sigman=1.0;
sigmas=sqrt(sigvar);
sigmac = sigman* inv_sqrt(lambda);
sigmad = sigmas* inv_sqrt(lambda);
// Reparameterization
for(i in 1:n) {
h[i] = Phi((0.5*d[i] - c[i])/sigmas);
f[i] = Phi((-0.5*d[i]  - c[i])/sigman);
}
}
model {
// Priors
lambda ~ gamma (0.5,0.5);
mud ~ normal (0,100);
muc ~ normal (0,100);
sigvar ~ normal (1,2) T[0, ];
// Discriminability and Bias
c ~ normal(muc, sigmac);
d ~ normal(mud, sigmad);
// Observed counts
HR ~ binomial(Si, h);
FA ~ binomial(No, f);
}
generated quantities {
vector[n] log_lik;
for (i in 1:n) {
log_lik[i] = binomial_lpmf(HR[i]|Si[i],h);
log_lik[i] = binomial_lpmf(FA[i]|No[i],f);
}
}
'
stanmodelH0 <- stan_model(model_code = HEVSD, model_name="stanmodel")
install.packages("Rtool")
install.packages("Rtools")
# clears workspace:
rm(list=ls())
library(rstan)
HEVSD <- "
// Hierarchical Signal Detection Theory
data {
int<lower=1> k;
int<lower=0> h[k];
int<lower=0> f[k];
int<lower=0> s;
int<lower=0> n;
}
parameters {
vector[k] d;
vector[k] c;
real muc;
real mud;
real<lower=0> lambdac;
real<lower=0> lambdad;
}
transformed parameters {
real<lower=0,upper=1> thetah[k];
real<lower=0,upper=1> thetaf[k];
real<lower=0> sigmac;
real<lower=0> sigmad;
sigmac = inv_sqrt(lambdac);
sigmad = inv_sqrt(lambdad);
// Reparameterization Using Equal-Variance Gaussian SDT
for(i in 1:k) {
thetah[i] = Phi(d[i] / 2 - c[i]);
thetaf[i] = Phi(-d[i] / 2 - c[i]);
}
}
model {
// Priors
muc ~ normal(0, inv_sqrt(.001));
mud ~ normal(0, inv_sqrt(.001));
lambdac ~ gamma(.001, .001);
lambdad ~ gamma(.001, .001);
// Discriminability and Bias
c ~ normal(muc, sigmac);
d ~ normal(mud, sigmad);
// Observed counts
h ~ binomial(s, thetah);
f ~ binomial(n, thetaf);
}"
HUSVD <-'
data {
int <lower=1> n;
int <lower=0> HR[n];
int <lower=0> FA[n];
int <lower=0> Si[n];
int <lower=0> No[n];
}
parameters {
vector[n] d;
vector[n] c;
real muc;
real mud;
real<lower=0> lambda;
real<lower=0> sigvar;
}
transformed parameters {
real<lower=0,upper=1> h[n];
real<lower=0,upper=1> f[n];
real<lower=0> sigmas;
real<lower=0> sigmac;
real<lower=0> sigmad;
real sigman;
sigman=1.0;
sigmas=sqrt(sigvar);
sigmac = sigman* inv_sqrt(lambda);
sigmad = sigmas* inv_sqrt(lambda);
// Reparameterization
for(i in 1:n) {
h[i] = Phi((0.5*d[i] - c[i])/sigmas);
f[i] = Phi((-0.5*d[i]  - c[i])/sigman);
}
}
model {
// Priors
lambda ~ gamma (0.5,0.5);
mud ~ normal (0,100);
muc ~ normal (0,100);
sigvar ~ normal (1,2) T[0, ];
// Discriminability and Bias
c ~ normal(muc, sigmac);
d ~ normal(mud, sigmad);
// Observed counts
HR ~ binomial(Si, h);
FA ~ binomial(No, f);
}
generated quantities {
vector[n] log_lik;
for (i in 1:n) {
log_lik[i] = binomial_lpmf(HR[i]|Si[i],h);
log_lik[i] = binomial_lpmf(FA[i]|No[i],f);
}
}
'
stanmodelH0 <- stan_model(model_code = HEVSD, model_name="stanmodel")
stanmodelH1 <- stan_model(model_code = HUSVD, model_name="stanmodel")
remove.packages("rstan", lib="~/R/win-library/4.0")
install.packges("rstan")
install.packages("rstan")
install.packages("rstan")
install.packages("rstan")
# clears workspace:
rm(list=ls())
library(rstan)
HEVSD <- "
// Hierarchical Signal Detection Theory
data {
int<lower=1> k;
int<lower=0> h[k];
int<lower=0> f[k];
int<lower=0> s;
int<lower=0> n;
}
parameters {
vector[k] d;
vector[k] c;
real muc;
real mud;
real<lower=0> lambdac;
real<lower=0> lambdad;
}
transformed parameters {
real<lower=0,upper=1> thetah[k];
real<lower=0,upper=1> thetaf[k];
real<lower=0> sigmac;
real<lower=0> sigmad;
sigmac = inv_sqrt(lambdac);
sigmad = inv_sqrt(lambdad);
// Reparameterization Using Equal-Variance Gaussian SDT
for(i in 1:k) {
thetah[i] = Phi(d[i] / 2 - c[i]);
thetaf[i] = Phi(-d[i] / 2 - c[i]);
}
}
model {
// Priors
muc ~ normal(0, inv_sqrt(.001));
mud ~ normal(0, inv_sqrt(.001));
lambdac ~ gamma(.001, .001);
lambdad ~ gamma(.001, .001);
// Discriminability and Bias
c ~ normal(muc, sigmac);
d ~ normal(mud, sigmad);
// Observed counts
h ~ binomial(s, thetah);
f ~ binomial(n, thetaf);
}"
HUSVD <-'
data {
int <lower=1> n;
int <lower=0> HR[n];
int <lower=0> FA[n];
int <lower=0> Si[n];
int <lower=0> No[n];
}
parameters {
vector[n] d;
vector[n] c;
real muc;
real mud;
real<lower=0> lambda;
real<lower=0> sigvar;
}
transformed parameters {
real<lower=0,upper=1> h[n];
real<lower=0,upper=1> f[n];
real<lower=0> sigmas;
real<lower=0> sigmac;
real<lower=0> sigmad;
real sigman;
sigman=1.0;
sigmas=sqrt(sigvar);
sigmac = sigman* inv_sqrt(lambda);
sigmad = sigmas* inv_sqrt(lambda);
// Reparameterization
for(i in 1:n) {
h[i] = Phi((0.5*d[i] - c[i])/sigmas);
f[i] = Phi((-0.5*d[i]  - c[i])/sigman);
}
}
model {
// Priors
lambda ~ gamma (0.5,0.5);
mud ~ normal (0,100);
muc ~ normal (0,100);
sigvar ~ normal (1,2) T[0, ];
// Discriminability and Bias
c ~ normal(muc, sigmac);
d ~ normal(mud, sigmad);
// Observed counts
HR ~ binomial(Si, h);
FA ~ binomial(No, f);
}
generated quantities {
vector[n] log_lik;
for (i in 1:n) {
log_lik[i] = binomial_lpmf(HR[i]|Si[i],h);
log_lik[i] = binomial_lpmf(FA[i]|No[i],f);
}
}
'
stanmodelH0 <- stan_model(model_code = HEVSD)
Sys.getenv("PATH")
devtools::install_version("rstan", version = "2.21.1", repos = "http://cran.us.r-project.org")
shiny::runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
runApp('C:/Users/Maximilian Maier/Desktop/MasterThesis/Experiment')
?decov
library(rstanarm)
?decov
help("priors", package = "rstanarm")
?decov
prob <- seq(0,1, 0.001)
prob <- seq(0,1, 0.001)
probs <- beta(1+ 5*prob, 1 + 5*(1-prob))
beta
prob <- seq(0,1, 0.001)
probs <- (1+ 5*prob/1 + 5*(1-prob))
plot(prob, probs)
prob <- seq(0,1, 0.001)
probs <- (1+ 5*prob)/(1 + 5*(1-prob))
plot(prob, probs)
prob <- seq(0,1, 0.001)
probs <- (1+ 5*prob)/((1 + 5*(1-prob)) + (1+ 5*prob))
plot(prob, probs)
prob <- seq(0,1, 0.001)
probs <- (1+ 5*prob)/((1 + 5*(1-prob)) + ( 1 + 5*prob))
plot(prob, probs)
prob <- seq(0,1, 0.001)
probs <- (1+ prob)/((1 + (1-prob)) + (1 + prob))
plot(prob, probs)
mean(rbeta(10000, 2, 3))
prob <- seq(0,1, 0.001)
probs <- (1+ prob*10)/((1 + 10*(1-prob)) + (1 + 10*prob))
plot(prob, probs)
prob <- seq(0,1, 0.01)
prob <- seq(0,1, 0.01)
probs <- (1 + prob*1/prob)/((1 + 1/prob*(1-prob)) + (1 + 1/prob*prob))
plot(prob, probs)
prob1 <- seq(0, 0.5, 0.01)
prob2 <- seq(0.5, 1, 0.01)
probs1 <- (1 + prob*1/prob)/((1 + 1/prob*(1-prob)) + (1 + 1/prob*prob))
probs2 <- (1 + prob*1/(1-prob)/((1 + 1/(1-prob)*(1-prob)) + (1 + 1/(1-prob)*prob))
plot(prob, probs)
prob1 <- seq(0, 0.5, 0.01)
prob2 <- seq(0.5, 1, 0.01)
probs1 <- (1 + prob*1/prob)/((1 + 1/prob*(1-prob)) + (1 + 1/prob*prob))
probs2 <- (1 + prob*1/(1-prob)/((1 + 1/(1-prob)*(1-prob)) + (1 + 1/(1-prob)*prob))
plot(c(prob1, prob2), c(probs1, probs2))
probs2 <- (1 + prob*1/(1-prob)/((1 + 1/(1-prob)*(1-prob)) + (1 + 1/(1-prob)*prob))
prob1 <- seq(0, 0.5, 0.01)
prob2 <- seq(0.5, 1, 0.01)
probs1 <- (1 + prob*1/prob)/((1 + 1/prob*(1-prob)) + (1 + 1/prob*prob))
probs2 <- (1 + prob*1/(1-prob))/((1 + 1/(1-prob)*(1-prob)) + (1 + 1/(1-prob)*prob))
plot(c(prob1, prob2), c(probs1, probs2))
prob1 <- seq(0, 0.5, 0.01)
prob2 <- seq(0.5, 1, 0.01)
probs1 <- (1 + prob1*1/prob1)/((1 + 1/prob1*(1-prob1)) + (1 + 1/prob1*prob1))
probs2 <- (1 + prob2*1/(1-prob2))/((1 + 1/(1-prob2)*(1-prob2)) + (1 + 1/(1-prob2)*prob2))
plot(c(prob1, prob2), c(probs1, probs2))
plot(c(prob1, prob2), c(probs1, probs2), type = "l")
plot(c(prob1, prob2), c(probs1, probs2), type = "l", lwd = 3, xlab = "Objective Probability", ylab = "Subjective Probability")
setwd("C:/Users/Maximilian Maier/Desktop/MasterThesis/Analysis")
ml <- readRDS("spiketestnormal.RDS")
mldist <- readRDS("disttestnormal.RDS")
mlmix <- readRDS("mixtestnormal.RDS")
plot(density(ml), ylim = c(0, 0.04), main = "Distribution of Log Marginal Likelihoods in the 3 Groups")
lines(density(mldist), col = "green")
lines(density(mlmix), col = "blue")
mlmix
datatest(cbind(ml, mldist, rep(1:15, 7)))
datatest <- cbind(ml, mldist, rep(1:15, 7))
datatest <- subset(datatest(1:100, ))
datatest <- datatest[1:100, ]
datatest
library(gplots)
datatest$ml
datatest <- as.data.frame(datatest[1:100, ])
datatest
plotmeans(ml ~ V3, data = datatest)
plotmeans(ml + mldist ~ V3, data = datatest)
datatest$deltaml <- datatest$ml - datatest$mldist
plotmeans(deltaml ~ V3, data = datatest)
setwd("C:/Users/Maximilian Maier/Desktop/PaperWriting/IdealAlpha/JustifieR")
warnings()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
setwd("C:/Users/Maximilian Maier/Desktop/PaperWriting/IdealAlpha/JustifyAlpha/R")
devtools::check()
